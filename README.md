$f(z) = z^2 + c$

This is happening in [[Linear Algebra Done Right|the complex plane]]. ($a + bi$)

Magnitude (Distance):
![[Pasted image 20240706140645.png]]

back to the $f_c(z) = z^2 + c$ 
- $c$ is just a complex number (and a constant)
- what we are interested in is the behavior of 0 under iteration of $f_c$
- There are 2 cases where this can go:
		- Case 1: is where the output blows up!![[Pasted image 20240706140916.png]]
		- Case 2: is where the output never leaves 0 too far (distance is bounded, never larger than 2!)![[Pasted image 20240706140941.png]]

Definition of the Mandrelbrot Set:
- the set of complex numbers' $c$ for which **Case 2** holds (bounded) ![[Pasted image 20240706141309.png]]
- All of this never leaves 2:![[Pasted image 20240706141638.png]]

If we want to draw it:
- starting iterating 0 under $z^2 + c$ 
	- if it takes a long time to get big, give it one color
	- if it gets big really quickly, then give it another

The complex plane range that we are interested in, for Mandelbrot set, generally spans from:
- Real part (Re): approximately `[-2.5 , 1]`
- Imaginary part (Im): approximately `[-1.0, 1.0]`

### Basic Concept

1. **Complex Numbers**:
    - A complex number $c$ is in the form $a+bi$, where $a$ is the real part and $b$ is the imaginary part.
2. **The Iterative Function**:
    - The Mandelbrot set is generated by iterating the function $z_{n+1}=z_n^2+c$.
    - Starting with $z_0=0$, you repeatedly apply this function to get $z_1,z_2,z_3,…$

### Membership in the Mandelbrot Set

A complex number $c$ is part of the Mandelbrot set if the sequence $|z_n|$ does not escape to infinity no matter how many times you apply the function. In practical terms, we check if the magnitude (or absolute value) of $|z_n|$ remains bounded.

### Role of Iterations

More iterations of the Mandelbrot set allow you to 'zoom in' and still see more details because each iteration refines the calculations, revealing finer structures and complex patterns. The Mandelbrot set is defined by a recursive function, and higher iterations check the stability of points more thoroughly, uncovering intricate details at smaller scales, which are otherwise missed in lower iterations.

1. **Escape Criterion**:
    - We say that $z_n$​ has escaped to infinity if its magnitude exceeds 2.
    - In practice, we limit the number of iterations (e.g., 255 iterations). If $|z_n|$ exceeds 2 within these iterations, we conclude that $c$ is not in the Mandelbrot set.
2. **Coloring the Set**:
    - If $c$ is in the Mandelbrot set, $|z_n|$ will not exceed 2 within the given number of iterations.
    - We color points based on the iteration count when $|z_n|$ first exceeds 2. The higher the iteration count, the closer the point is to the Mandelbrot set boundary.

### Steps to Create the Animation

1. **Set up the project**.
2. **Initialize the graphical window**.
3. **Handle user input**.
4. **Smoothly interpolate between zoom levels**.
	1. See [[Linear Interpolation (LERP)]]
5. **Render the Mandelbrot set**.

```
The basic structure is here. But the performance is very poor. My CPU is screaming and is running at 100%.
```

Note from 2024-07-09: This marks the completion of mandelbrot (version 1). I didn't have the time (nor the mood) to write about it at the time. The program runs just fine but it clearly needed a few tweaks. I can run it with 255 iterations semi-comfortably but very far from acceptable. I tried running it at 1,000 iterations and was pretty sure it would have baked my CPU if I kept at it any longer.  This is later improved by [[#Offloading to GPU|offloading the main mandelbrot calculation function to GPU]], which is apparently much better at parallels processing than multi-core CPU. My CPU has somewhere between 4-cores and 8-cores. GPU, however, has more than 10K.
## 2024-07-07
Using SIMD:
`Cargo.toml`
```
packed_simd = "0.3.4"
```

```rust
extern crate packed_simd;
use packed_simd::f64x4;
[...]
fn generate_mandelbrot(imgx: u32, imgy: u32, max_iter: usize, center_x: f64, center_y: f64, zoom: f64) -> RgbaImage {
    let aspect_ratio = imgx as f64 / imgy as f64;
    let scale_x = 3.5 / (imgx as f64) / zoom;
    let scale_y = scale_x / aspect_ratio;

    let mut imgbuf = ImageBuffer::new(imgx, imgy);

    imgbuf.enumerate_pixels_mut().par_bridge().for_each(|(x, y, pixel)| {
        let cx = center_x + (x as f64 - imgx as f64 / 2.0) * scale_x;
        let cy = center_y + (y as f64 - imgy as f64 / 2.0) * scale_y;

        // SIMD calculations
        let c_re = f64x4::splat(cx);
        let c_im = f64x4::splat(cy);

        let mut z_re = f64x4::splat(0.0);
        let mut z_im = f64x4::splat(0.0);
        let mut is_inside = f64x4::splat(1.0);

        let mut iter = 0;
        for _ in 0..max_iter {
            let z_re2 = z_re * z_re;
            let z_im2 = z_im * z_im;
            let magnitude = z_re2 + z_im2;
            let mask = magnitude.lt(f64x4::splat(4.0));
            if mask.none() {
                break;
            }

            z_im = f64x4::splat(2.0) * z_re * z_im + c_im;
            z_re = z_re2 - z_im2 + c_re;

            iter += 1;
            is_inside &= mask.cast();
        }

        let color = if is_inside.any() {
            get_color(iter, max_iter)
        } else {
            [0, 0, 0, 255]
        };

        *pixel = Rgba(color);
    });

    imgbuf
}
```

Doesn't work. It seems SIMD is still very experimental and not compatible with stable rust. We can use nightly rust but I don't feel like playing with it just yet.

This idea seems more promising:
https://math.stackexchange.com/questions/16970/a-way-to-determine-the-ideal-number-of-maximum-iterations-for-an-arbitrary-zoom

Next, we can try, instead of running solely on CPU, offloading the Mandelbrot set computations to your GPU. This can be achieved using frameworks like `wgpu`, `CUDA`, or `OpenCL`.

## Offloading to GPU

Yes, you are correct. When using the GPU to compute the Mandelbrot set, the computation is offloaded to the kernel written in OpenCL's C-like language. Therefore, the Rust implementation of the Mandelbrot calculation function will not be necessary.
```
I asked if the kernel code below would replace mandelbrot.rs since the calculation seems very similar.
```

To integrate this change properly, here is a more detailed explanation and the final adjustments you need to make:

### Step-by-Step Integration

1. **Write the OpenCL Kernel**:
    - This kernel is responsible for performing the Mandelbrot calculation on the GPU.

```c
__kernel void mandelbrot(
    __global uchar4* img,
    const float center_x,
    const float center_y,
    const float scale_x,
    const float scale_y,
    const unsigned int max_iter,
    const unsigned int imgx,
    const unsigned int imgy)
{
    int x = get_global_id(0);
    int y = get_global_id(1);

    float cx = center_x + (x - imgx / 2.0) * scale_x;
    float cy = center_y + (y - imgy / 2.0) * scale_y;
    
    float zx = 0.0;
    float zy = 0.0;
    unsigned int iter = 0;
    
    while (zx * zx + zy * zy < 4.0 && iter < max_iter) {
        float tmp = zx * zx - zy * zy + cx;
        zy = 2.0 * zx * zy + cy;
        zx = tmp;
        iter++;
    }
    
    uchar4 color = (uchar4)(0, 0, 0, 255); // default color
    if (iter < max_iter) {
        int color_idx = iter % 22;
        uchar4 colors[] = {
            (uchar4)(0, 0, 0, 255), (uchar4)(0, 0, 64, 255), (uchar4)(0, 0, 128, 255),
            (uchar4)(0, 0, 255, 255), (uchar4)(0, 64, 255, 255), (uchar4)(0, 128, 255, 255),
            (uchar4)(0, 255, 255, 255), (uchar4)(64, 255, 255, 255), (uchar4)(128, 255, 255, 255),
            (uchar4)(255, 255, 255, 255), (uchar4)(255, 255, 128, 255), (uchar4)(255, 255, 64, 255),
            (uchar4)(255, 255, 0, 255), (uchar4)(255, 128, 0, 255), (uchar4)(255, 64, 0, 255),
            (uchar4)(255, 0, 0, 255), (uchar4)(128, 0, 0, 255), (uchar4)(64, 0, 0, 255),
            (uchar4)(128, 0, 128, 255), (uchar4)(255, 0, 255, 255), (uchar4)(128, 0, 255, 255),
            (uchar4)(64, 0, 128, 255)
        };
        color = colors[color_idx];
    }
    
    img[y * imgx + x] = color;
}
```

### Step 2: Adjust the Rust Code

Remove the existing Rust Mandelbrot calculation function and integrate the GPU-based computation. Below is a more detailed integration, keeping your main loop and other functions intact:

#### initialize_opencl

```rust
pub fn initialize_opencl() -> (Context, CommandQueue, Kernel) { 
// Get all available OpenCL platforms 
let platform = get_all_platforms().unwrap()[0]; 
// Get a GPU device from the platform 
let device = Device::new(platform.get_devices(CL_DEVICE_TYPE_GPU).unwrap()[0]); 
// Create a context for the device 
let context = Context::from_device(&device).unwrap(); 
// Create a command queue for the device 
let queue = CommandQueue::create(&context, device.id(), CL_QUEUE_PROFILING_ENABLE).unwrap(); 
// Create and build the program from the source kernel code 
let program = Program::create_and_build_from_source(&context, MANDELBROT_KERNEL, "").unwrap(); 
// Create the kernel from the program 
let kernel = Kernel::create(&program, "mandelbrot").unwrap(); (context, queue, kernel) 
}
```

#### Adjusted `generate_mandelbrot_opencl` function:

```rust
fn generate_mandelbrot_opencl(
    imgx: u32, imgy: u32, max_iter: usize,
    center_x: f64, center_y: f64, scale_x: f64, scale_y: f64,
    context: &Context, queue: &CommandQueue, kernel: &Kernel
) -> RgbaImage {
    let mut imgbuf = ImageBuffer::new(imgx, imgy);

    let buffer_size = (imgx * imgy * 4) as usize;
    let mut buffer = vec![0u8; buffer_size];

    let img_buf = context.create_buffer::<u8>(CL_MEM_WRITE_ONLY, buffer_size, ptr::null_mut()).unwrap();

    kernel.set_arg(0, &img_buf).unwrap();
    kernel.set_arg(1, &center_x as *const f64 as *const c_void).unwrap();
    kernel.set_arg(2, &center_y as *const f64 as *const c_void).unwrap();
    kernel.set_arg(3, &scale_x as *const f64 as *const c_void).unwrap();
    kernel.set_arg(4, &scale_y as *const f64 as *const c_void).unwrap();
    kernel.set_arg(5, &max_iter as *const usize as *const c_void).unwrap();
    kernel.set_arg(6, &imgx as *const u32 as *const c_void).unwrap();
    kernel.set_arg(7, &imgy as *const u32 as *const c_void).unwrap();

    let global_work_size = [imgx as usize, imgy as usize];
    unsafe {
        queue.enqueue_nd_range_kernel(&kernel, None, &global_work_size, None, &[]).unwrap();
    }

    queue.enqueue_read_buffer(&img_buf, CL_BLOCKING, 0, &mut buffer, &[]).unwrap();

    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {
        let idx = ((y * imgx + x) * 4) as usize;
        *pixel = Rgba([buffer[idx], buffer[idx + 1], buffer[idx + 2], buffer[idx + 3]]);
    }

    imgbuf
}
```

### Step 3: Integrate into `main` function

Update your `main` function to call `generate_mandelbrot_opencl`:

```rust
fn main() {
    let mut window: PistonWindow = WindowSettings::new("Look into it.", [800, 800])
        .exit_on_esc(true)
        .build()
        .unwrap();

    let (context, queue, kernel) = initialize_opencl();

    let mut center_x = -0.75;
    let mut center_y = 0.0;
    let mut zoom = 1.0;
    let mut target_center_x = center_x;
    let mut target_center_y = center_y;
    let mut target_zoom = 1.0;

    let mut cursor_position: [f64; 2] = [0.0, 0.0];

    let mut texture_context = window.create_texture_context();

    while let Some(event) = window.next() {
        if let Some(Button::Mouse(MouseButton::Left)) = event.press_args() {
            let (x, y) = (cursor_position[0], cursor_position[1]);
            let cx = center_x + (x / 800.0 - 0.5) * 3.5 / zoom;
            let cy = center_y + (y / 800.0 - 0.5) * 2.0 / zoom;
            target_center_x = cx;
            target_center_y = cy;
            target_zoom *= 2.0;
            println!("Zooming in: Center ({}, {}), Zoom {}", target_center_x, target_center_y, target_zoom);
        }
        if let Some(Button::Mouse(MouseButton::Right)) = event.press_args() {
            let (x, y) = (cursor_position[0], cursor_position[1]);
            let cx = center_x + (x / 800.0 - 0.5) * 3.5 / zoom;
            let cy = center_y + (y / 800.0 - 0.5) * 2.0 / zoom;
            target_center_x = cx;
            target_center_y = cy;
            target_zoom /= 2.0;
            println!("Zooming out: Center ({}, {}), Zoom {}", target_center_x, target_center_y, target_zoom);
        }
        if let Some([x, y]) = event.mouse_cursor_args() {
            cursor_position = [x, y];
        }

        let lerp_factor = 0.1;
        center_x += (target_center_x - center_x) * lerp_factor;
        center_y += (target_center_y - center_y) * lerp_factor;
        zoom += (target_zoom - zoom) * lerp_factor;

        window.draw_2d(&event, |c, g, _device| {
            clear([1.0; 4], g);
            let (scale_x, scale_y) = calculate_scales(800, 800, zoom);
            let img = generate_mandelbrot_opencl(800, 800, 100, center_x, center_y, scale_x, scale_y, &context, &queue, &kernel);
            let texture: G2dTexture = Texture::from_image(&mut texture_context, &img, &TextureSettings::new()).unwrap();
            image(&texture, c.transform, g);
        });
    }
}
```

### Summary

With these modifications, your Mandelbrot set generation will now be offloaded to the GPU using OpenCL, thus leveraging the GPU's computational power to accelerate the rendering process. The Rust-based Mandelbrot function is no longer needed, as its functionality has been replaced by the OpenCL kernel. This should significantly improve performance, especially for large images or high iteration counts.

See this [link](https://www.youtube.com/watch?v=pPStdjuYzSI) for CUDA

## 2024-07-09

Here is the day of mandelbrot2 genesis. It is working!

However, we've encountered an issue. I can only zoom into it up to 200K and started seeing pixels (as compared to mandelbrot1 where we can zoom up to 2B without the image getting pixelated).

There is no point for better performance if we can't really explore the inifinity of Mset.

From ChatGPT:
```
When using the CPU, the calculations might inherently have more precision and may be better at handling deeper zooms without adjusting the number of iterations. The CPU can handle larger floating-point precision (e.g., using `f64`) which allows it to compute more accurate values even when zoomed in deeply. The GPU, on the other hand, typically performs better with `f32` for performance reasons, but this can reduce precision and show pixelation at higher zoom levels.
```
- possibly because we used f32 instead of f64 in the kernel

To achieve similar quality on the GPU as you did on the CPU, you can:
1. **Increase Precision**: Use double precision (`f64`) in your GPU calculations if supported.
2. **Increase Iterations**: Dynamically increase the number of iterations as you zoom in.
3. **Use High-Precision Libraries**: Consider using or implementing high-precision arithmetic libraries for GPUs.

### Increase Precision

We can add this line before the kernel to enable `cl_khr_fp64` to use `f64`:
```
#pragma OPENCL EXTENSION cl_khr_fp64 : enable
```
- change the variable declarations accordingly `float` -> `double`

### I miss the old color function

Let's try it again:
```
fn get_color(iter: usize, max_iter: usize) -> [u8; 4] {
    if iter == max_iter {
        [0, 0, 0, 255]
    } else {
        let t = iter as f64 / max_iter as f64;
        let r = (9.0 * (1.0 - t) * t * t * t * 255.0) as u8;
        let g = (15.0 * (1.0 - t) * (1.0 - t) * t * t * 255.0) as u8;
        let b = (8.5 * (1.0 - t) * (1.0 - t) * (1.0 - t) * t * 255.0) as u8;
        [r, g, b, 255]
    }
}
```

![[Pasted image 20240709215141.png]]

This is the curve for each color.
- remember that $t = \frac{iter}{max iter}$ 
- at $t = 1$, it means that $iter = maxiter$
-  as $t$ approaches 1, $(r, g, b)$ changes according to the cubic polynomial, creating a gradient.
- For $b$, notice that $(1-t)$ is cubed. This cubic term decreases more rapidly as `t` increases, emphasizing the effect of smaller `t` values.
	- Points in the blue area represent complex numbers that escape to infinity in relatively few iterations.

### Look into it.
![[Pasted image 20240709221726.png]]

![[Pasted image 20240709222356.png]]

I didn't understand most of the code still, but we've got a structure for our next fractal stuffs. Next we'll try to focus on understanding what is going on, optimize whatever we can, and we can move on to other sets (see you Julia).

```
fn calculate_scales(imgx: u32, imgy: u32, zoom: f64) -> (f64, f64) {
    let scale_x = 3.5 / imgx as f64 / zoom;
    let scale_y = 3.5 / imgy as f64 / zoom;
    (scale_x, scale_y)
}
```
- this function in particular feels pointless, since I want the scale to be a fixed value anyway.

## Update: 2024-07-11

```
From looking around and poking the thing, I've noticed that zooming in on certain areas of Mset, we faces 2 different kinds of limitation:
1. Pixelation (This is when the zoom level get so high and we start to see pixels)
2. Lack of details (after zooming in a bit, an area can become more 'rounded' and lacking in details, marking the end-point for our journey)

Initially, I thought both pixelation and lack of details solely attributable to the no. of iterations. However, it appears that they are from 2 different causes (namely, limitations of f64 and no. of iterations).

Note: by 'limitations', I'm referring to how 'interesting' the image and how 'deep' we can go. 
```

The Mandelbrot set is a fractal, which means it exhibits self-similarity and intricate detail at infinitely small scales. However, when rendering the Mandelbrot set, two main limitations can affect the quality of the image at very high zoom levels:

1. **Iteration Limit**:
    - The iteration limit affects how accurately the boundaries of the Mandelbrot set are rendered. When the iteration limit is too low, the boundaries of the set can appear smooth and rounded instead of showing the intricate details characteristic of the fractal.
    - Increasing the iteration limit allows for more detailed and accurate rendering of the set's boundaries, especially at high zoom levels. However, this also increases the computational load.
    - `Zooming in: Center (-1.768550432749661, 0.0006619699917632335), Zoom 262144` (notice the low zoom level)![[Pasted image 20240711185222.png]]
1. **Floating-Point Precision**:
    - The precision of the floating-point numbers (typically `f64`) used in calculations affects the ability to accurately represent points in the complex plane. At very high zoom levels, the differences between points become extremely small, and the limited precision of floating-point numbers can lead to inaccuracies, resulting in pixilation or artifacts.
    - Using arbitrary-precision arithmetic can help mitigate this issue, but it comes at the cost of increased computational complexity.
    - `Zooming out: Center (-1.7801248114887231, 0.0000017211612254349696), Zoom 70368744177664`![[Pasted image 20240711185400.png]]

### Why Different Areas Exhibit Different Limits

1. **Smooth Areas vs. Detailed Areas**:
    - Some areas of the Mandelbrot set are inherently less detailed and more "smooth." When you zoom into these areas, the iteration limit becomes the dominant factor because fewer iterations are needed to escape the set, leading to smoother, less detailed boundaries.
    - In more detailed areas, such as near the boundary of the main cardioid or near minibrots (mini Mandelbrot sets), the intricate details require higher iteration limits to be accurately rendered. Without enough iterations, these details become rounded and lose their complexity.
2. **Precision Limits**:
    - When zooming into areas with very fine detail, the floating-point precision limit becomes apparent. At extreme zoom levels, the differences between points in the complex plane become smaller than what can be accurately represented with `f64` precision, leading to pixelation and loss of detail.
    - This is why you may see the limit of zoom (pixelation) in some areas, as the precision of the calculations is insufficient to represent the fractal's details accurately.

### Another issue...

There seems to a scaling issues and pixels just cannot be squares (should it be a square?). The position of the pixel seems to have effect on its stretch. You should look into this.
